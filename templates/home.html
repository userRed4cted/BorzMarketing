<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ site_config.page_titles.home }}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='responsive.css') }}">
    {% include 'partials/config_styles.html' %}
    {% if session.get('user') %}
    <script src="{{ url_for('static', filename='tab_enforcement.js') }}"></script>
    {% endif %}
    <script>
        window.DB_VERSION = {{ db_version }};
        window.DB_WIPE_MESSAGE = "{{ db_wipe_message }}";
    </script>
    <script src="{{ url_for('static', filename='db_wipe_notice.js') }}"></script>
    <style>
        /* Dynamic fade duration from config */
        .hero-title {
            transition: opacity {{ slideshow_fade_duration }}ms ease !important;
        }

        /* Water ripple effect canvas */
        #ripple-canvas {
            position: fixed;
            top: 60px; /* Below navbar */
            left: 0;
            width: 100%;
            height: calc(100vh - 60px);
            pointer-events: none;
            z-index: 1;
        }

        .panel {
            position: relative;
            z-index: 2;
        }

        /* Make about section transparent so particles show through */
        .about-section {
            background: transparent !important;
        }

        /* Keep gallery section above the canvas with its original background */
        .gallery-section {
            position: relative;
            z-index: 3;
        }

        .navbar {
            position: relative;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <!-- Water ripple effect canvas -->
    <canvas id="ripple-canvas"></canvas>

    <div class="panel">
        <nav class="navbar">
            <div class="navbar-content">
                <div class="navbar-left">
                    <div class="menu-icon" id="menu-icon">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="3" y1="12" x2="21" y2="12"></line>
                            <line x1="3" y1="6" x2="21" y2="6"></line>
                            <line x1="3" y1="18" x2="21" y2="18"></line>
                        </svg>
                    </div>
                    <div class="navbar-text">
                        <h1 class="navbar-title">{{ site_title }}</h1>
                        <p class="navbar-subtitle">{{ site_subtitle }}</p>
                    </div>
                </div>
                <div class="nav-right">
                    {% if session.get('user') %}
                        <div class="user-info">
                            {% if session['user'].avatar %}
                                <img src="https://cdn.discordapp.com/avatars/{{ session['user'].id }}/{{ session['user'].avatar }}.png" alt="{{ session['user'].username }}" class="user-avatar">
                            {% else %}
                                <div class="user-avatar-placeholder">{{ session['user'].username[0].upper() }}</div>
                            {% endif %}
                            <div class="user-details">
                                <div class="username">{{ session['user'].username }}</div>
                                <div class="user-id">{{ session['user'].id }}</div>
                            </div>
                        </div>
                    {% else %}
                        <div class="auth-buttons">
                            <a href="{{ url_for('login_page') }}" class="auth-btn login-btn">{{ auth_labels.login }}</a>
                            <a href="{{ url_for('signup_page') }}" class="auth-btn signup-btn">{{ auth_labels.signup }}</a>
                        </div>
                    {% endif %}
                </div>
            </div>

            <!-- Dropdown Menu -->
            <div class="dropdown-menu" id="dropdown-menu">
                <a href="{{ url_for('home') }}" class="dropdown-item">{{ nav_labels.home }}</a>
                <a href="{{ url_for('purchase') }}" class="dropdown-item">{{ nav_labels.purchase }}</a>
                {% if session.get('user') %}
                    {% if plan_status and plan_status.has_plan and not (plan_status.plan_id and plan_status.plan_id.startswith('business_')) %}
                        <a href="{{ url_for('panel') }}" class="dropdown-item">{{ nav_labels.panel }}</a>
                    {% endif %}
                    {% if has_business %}
                    {% if is_owner %}
                    <a href="{{ url_for('business_management') }}" class="dropdown-item">{{ nav_labels.business_management }}</a>
                    {% endif %}
                    <a href="{{ url_for('business_panel') }}" class="dropdown-item">{{ nav_labels.business_panel }}</a>
                    {% endif %}
                    <a href="{{ url_for('settings') }}" class="dropdown-item">{{ nav_labels.settings }}</a>
                    {% if is_admin_user %}
                    <a href="{{ url_for('admin_panel') }}" class="dropdown-item">{{ nav_labels.admin }}</a>
                    {% endif %}
                {% endif %}
                <div class="dropdown-divider"></div>
                <a href="{{ discord_invite_url }}" target="_blank" class="dropdown-item discord-item">{{ nav_labels.discord }}</a>
                {% if session.get('user') %}
                    <a href="{{ url_for('logout') }}" class="dropdown-item logout-item">{{ nav_labels.logout }}</a>
                {% endif %}
            </div>
        </nav>

        <div class="panel-container">
            <div class="home-content">
                <div class="hero-section">
                    <h2 class="hero-title" id="hero-title">{{ slideshow_messages[0] }}</h2>
                    <a href="{{ url_for('purchase') }}" class="view-pricing-btn">{{ hero_cta_button_text }}</a>
                    <div class="scroll-indicator" id="scroll-indicator">
                        <span class="scroll-text">{{ scroll_indicator_text }}</span>
                        <div class="scroll-arrow">&#8595;</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Gallery Section -->
        <section class="gallery-section">
            <h2 class="gallery-title">{{ gallery_title }}</h2>
            <div class="gallery-grid">
                {% for image in gallery_images %}
                <div class="gallery-item" onclick="openLightbox({{ loop.index0 }})">
                    <img src="{{ url_for('static', filename=image) }}" alt="Panel Screenshot {{ loop.index }}">
                </div>
                {% endfor %}
            </div>
        </section>

        <!-- About Section -->
        <section class="about-section">
            <h2 class="about-title">{{ about_title }}</h2>
            <p class="about-description">{{ about_description }}</p>
        </section>
    </div>

    <!-- Lightbox -->
    <div class="lightbox" id="lightbox" onclick="closeLightboxOnBackground(event)">
        <div class="lightbox-content">
            <button class="lightbox-close" onclick="closeLightbox()">&times;</button>
            <button class="lightbox-nav lightbox-prev" onclick="prevImage(event)">&larr;</button>
            <img id="lightbox-img" src="" alt="Panel Screenshot">
            <button class="lightbox-nav lightbox-next" onclick="nextImage(event)">&rarr;</button>
            <div class="lightbox-counter">
                <span id="current-index">1</span> / <span id="total-images">{{ gallery_images|length }}</span>
            </div>
        </div>
    </div>

    <script>
        // Dropdown menu toggle
        const menuIcon = document.getElementById('menu-icon');
        const dropdownMenu = document.getElementById('dropdown-menu');

        if (menuIcon) {
            menuIcon.addEventListener('click', (e) => {
                e.stopPropagation();
                dropdownMenu.classList.toggle('show');
            });
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!dropdownMenu.contains(e.target) && !menuIcon.contains(e.target)) {
                dropdownMenu.classList.remove('show');
            }
        });

        // Hero text slideshow - uses requestAnimationFrame for background-safe timing
        const heroTitle = document.getElementById('hero-title');
        const messages = {{ slideshow_messages | tojson }};
        const interval = {{ slideshow_interval }};
        const fadeDuration = {{ slideshow_fade_duration }};
        let currentIndex = 0;
        let lastSlideTime = Date.now();

        function changeSlide() {
            // Fade out
            heroTitle.classList.add('fade-out');

            setTimeout(() => {
                // Change text
                currentIndex = (currentIndex + 1) % messages.length;
                heroTitle.textContent = messages[currentIndex];

                // Fade in
                heroTitle.classList.remove('fade-out');
                heroTitle.classList.add('fade-in');

                setTimeout(() => {
                    heroTitle.classList.remove('fade-in');
                }, fadeDuration);
            }, fadeDuration);
        }

        // Use requestAnimationFrame for smooth background-safe slideshow
        function slideshowLoop() {
            const now = Date.now();
            if (now - lastSlideTime >= interval) {
                changeSlide();
                lastSlideTime = now;
            }
            requestAnimationFrame(slideshowLoop);
        }

        // Start slideshow
        requestAnimationFrame(slideshowLoop);

        // Gallery Lightbox
        const images = [
            {% for image in gallery_images %}
            '{{ url_for('static', filename=image) }}'{% if not loop.last %},{% endif %}
            {% endfor %}
        ];
        let currentImageIndex = 0;

        function openLightbox(index) {
            currentImageIndex = index;
            const lightbox = document.getElementById('lightbox');
            const lightboxImg = document.getElementById('lightbox-img');
            lightboxImg.src = images[currentImageIndex];
            document.getElementById('current-index').textContent = currentImageIndex + 1;
            lightbox.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeLightbox() {
            const lightbox = document.getElementById('lightbox');
            lightbox.classList.remove('active');
            document.body.style.overflow = '';
        }

        function closeLightboxOnBackground(event) {
            if (event.target.id === 'lightbox') {
                closeLightbox();
            }
        }

        function prevImage(event) {
            event.stopPropagation();
            currentImageIndex = (currentImageIndex - 1 + images.length) % images.length;
            document.getElementById('lightbox-img').src = images[currentImageIndex];
            document.getElementById('current-index').textContent = currentImageIndex + 1;
        }

        function nextImage(event) {
            event.stopPropagation();
            currentImageIndex = (currentImageIndex + 1) % images.length;
            document.getElementById('lightbox-img').src = images[currentImageIndex];
            document.getElementById('current-index').textContent = currentImageIndex + 1;
        }

        // Keyboard navigation for lightbox
        document.addEventListener('keydown', function(event) {
            const lightbox = document.getElementById('lightbox');
            if (!lightbox.classList.contains('active')) return;

            if (event.key === 'Escape') closeLightbox();
            if (event.key === 'ArrowLeft') prevImage(event);
            if (event.key === 'ArrowRight') nextImage(event);
        });

        // Scroll indicator visibility
        const scrollIndicator = document.getElementById('scroll-indicator');
        window.addEventListener('scroll', function() {
            if (window.scrollY > 50) {
                scrollIndicator.classList.add('hidden');
            } else {
                scrollIndicator.classList.remove('hidden');
            }
        });

        // Liquid push effect
        (function() {
            const canvas = document.getElementById('ripple-canvas');
            const ctx = canvas.getContext('2d');
            const navbarHeight = 60;

            let mouseX = -1000;
            let mouseY = -1000;
            let particles = [];

            // Detect mobile and reduce particle count for performance
            const isMobile = window.innerWidth <= 768;
            const particleCount = isMobile ? 200 : 600;
            const pushRadius = isMobile ? 60 : 80;
            const pushStrength = 0.15;
            const connectionDistance = isMobile ? 40 : 60;

            // Resize canvas to viewport size (fixed positioning)
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight - navbarHeight;
                initParticles();
            }

            // Particle class
            class Particle {
                constructor() {
                    this.reset();
                }

                reset() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.originX = this.x;
                    this.originY = this.y;
                    this.vx = 0;
                    this.vy = 0;
                    this.radius = Math.random() * 2 + 1;
                    this.opacity = Math.random() * 0.3 + 0.1;
                }

                update() {
                    // Calculate distance from mouse/touch
                    const dx = this.x - mouseX;
                    const dy = this.y - mouseY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // Push particles away from cursor/touch
                    if (distance < pushRadius && distance > 0) {
                        const force = (pushRadius - distance) / pushRadius;
                        const angle = Math.atan2(dy, dx);
                        this.vx += Math.cos(angle) * force * pushStrength;
                        this.vy += Math.sin(angle) * force * pushStrength;
                    }

                    // Return to origin with smooth easing
                    const returnSpeed = 0.02;
                    this.vx += (this.originX - this.x) * returnSpeed;
                    this.vy += (this.originY - this.y) * returnSpeed;

                    // Apply friction
                    this.vx *= 0.92;
                    this.vy *= 0.92;

                    // Update position
                    this.x += this.vx;
                    this.y += this.vy;
                }

                draw() {
                    // Calculate displacement for visual feedback
                    const displacement = Math.sqrt(
                        Math.pow(this.x - this.originX, 2) +
                        Math.pow(this.y - this.originY, 2)
                    );
                    const glowOpacity = Math.min(this.opacity + displacement * 0.01, 0.6);

                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${glowOpacity})`;
                    ctx.fill();

                    // Draw connection lines between nearby particles (skip on mobile for performance)
                    if (!isMobile) {
                        particles.forEach(other => {
                            if (other === this) return;
                            const dx = other.x - this.x;
                            const dy = other.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < connectionDistance) {
                                ctx.beginPath();
                                ctx.moveTo(this.x, this.y);
                                ctx.lineTo(other.x, other.y);
                                ctx.strokeStyle = `rgba(255, 255, 255, ${0.05 * (1 - dist / connectionDistance)})`;
                                ctx.lineWidth = 0.5;
                                ctx.stroke();
                            }
                        });
                    }
                }
            }

            function initParticles() {
                particles = [];
                for (let i = 0; i < particleCount; i++) {
                    particles.push(new Particle());
                }
            }

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('load', resizeCanvas);

            // Track mouse movement (only below navbar)
            document.addEventListener('mousemove', function(e) {
                if (e.clientY > navbarHeight) {
                    mouseX = e.clientX;
                    mouseY = e.clientY - navbarHeight;
                } else {
                    mouseX = -1000;
                    mouseY = -1000;
                }
            });

            // Track touch movement for mobile
            document.addEventListener('touchmove', function(e) {
                const touch = e.touches[0];
                if (touch.clientY > navbarHeight) {
                    mouseX = touch.clientX;
                    mouseY = touch.clientY - navbarHeight;
                }
            }, { passive: true });

            document.addEventListener('touchstart', function(e) {
                const touch = e.touches[0];
                if (touch.clientY > navbarHeight) {
                    mouseX = touch.clientX;
                    mouseY = touch.clientY - navbarHeight;
                }
            }, { passive: true });

            document.addEventListener('touchend', function() {
                mouseX = -1000;
                mouseY = -1000;
            });

            // Mouse leaves window
            document.addEventListener('mouseleave', function() {
                mouseX = -1000;
                mouseY = -1000;
            });

            // Animation loop
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                particles.forEach(particle => {
                    particle.update();
                    particle.draw();
                });

                requestAnimationFrame(animate);
            }

            animate();
        })();
    </script>
</body>
</html>
