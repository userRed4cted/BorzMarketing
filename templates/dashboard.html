<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Discord Server Manager</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>
<body>
    <div class="panel">
        <nav class="navbar">
            <div class="navbar-content">
                <div class="navbar-left">
                    <div class="menu-icon" id="menu-icon">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="3" y1="12" x2="21" y2="12"></line>
                            <line x1="3" y1="6" x2="21" y2="6"></line>
                            <line x1="3" y1="18" x2="21" y2="18"></line>
                        </svg>
                    </div>
                    <div class="navbar-text">
                        <h1 class="navbar-title">Borz Marketing Panel</h1>
                        <p class="navbar-subtitle">Select in which servers and channels you would like to automate your marketing</p>
                    </div>
                </div>
                <div class="nav-right">
                    <div class="user-info">
                        {% if user.avatar %}
                            <img src="https://cdn.discordapp.com/avatars/{{ user.id }}/{{ user.avatar }}.png" alt="{{ user.username }}" class="user-avatar">
                        {% else %}
                            <div class="user-avatar-placeholder">{{ user.username[0].upper() }}</div>
                        {% endif %}
                        <div class="user-details">
                            <div class="username">{{ user.username }}</div>
                            <div class="user-id">{{ user.id }}</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Dropdown Menu -->
            <div class="dropdown-menu" id="dropdown-menu">
                <a href="{{ url_for('home') }}" class="dropdown-item">Home</a>
                <a href="{{ url_for('panel') }}" class="dropdown-item">Panel</a>
                <a href="{{ url_for('settings') }}" class="dropdown-item">Settings</a>
                <div class="dropdown-divider"></div>
                <a href="{{ url_for('logout') }}" class="dropdown-item logout-item">Logout</a>
            </div>
        </nav>

        <div class="panel-container">

            {% if guilds %}
                <div class="main-layout">
                    <!-- Left: Server and Channel Selection -->
                    <div class="selection-panel">
                        <!-- Unified Header for Left Panel -->
                        <div class="unified-header">
                            <div class="header-section">
                                <div class="panel-header">Your Servers</div>
                                <div class="server-search-container">
                                    <input type="text" id="server-search" class="search-input" placeholder="Search servers...">
                                </div>
                            </div>
                        </div>

                        <!-- Server List -->
                        <div class="servers-section">
                            <div id="servers-list" class="servers-list">
                                <!-- Servers will be populated by JavaScript -->
                            </div>
                        </div>

                        <!-- Channels List -->
                        <div class="channels-section">
                            <div class="panel-header">Channels</div>

                            <!-- Search Bar -->
                            <div class="channels-search">
                                <input type="text" id="channel-search" class="search-input" placeholder="Search channels...">
                                <div class="search-tags" id="search-tags"></div>
                            </div>

                            <div id="channels-list" class="channels-list">
                                <div class="no-selection">Select a server to view channels</div>
                            </div>
                            <div class="channels-notice">
                                All channels will show up here even if you don't have permission to send messages, due to the unavailability of a feature to check user channel permissions
                            </div>
                        </div>
                    </div>

                    <!-- Right: Selected Channels and Message -->
                    <div class="action-panel">
                        <!-- Unified Header for Right Panel -->
                        <div class="unified-header">
                            <div class="header-section">
                                <div class="panel-header">Selected Channels</div>
                                <div class="selected-search-container">
                                    <input type="text" id="selected-search" class="search-input" placeholder="Search selected channels...">
                                </div>
                            </div>
                        </div>

                        <!-- Selected Channels -->
                        <div class="selected-section">
                            <button class="clear-all-btn" id="clear-all-btn" style="display: none;">Clear all selected channels</button>
                            <div id="selected-channels-tags" class="selected-channels-tags">
                                <div class="no-selection">No channels selected</div>
                            </div>
                        </div>

                        <!-- Message Composer -->
                        <div class="message-section">
                            <textarea id="message-input" class="message-input" placeholder="Enter your message here..." maxlength="2000"></textarea>
                            <div class="message-footer">
                                <span class="char-count"><span id="char-count">0</span>/2000</span>
                                <button id="send-btn" class="send-button" disabled>
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <line x1="22" y1="2" x2="11" y2="13"></line>
                                        <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                                    </svg>
                                    Send
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            {% else %}
                <div class="empty-state">
                    <div class="empty-icon">üîç</div>
                    <h2>No Servers Found</h2>
                    <p>You don't have access to any Discord servers yet</p>
                </div>
            {% endif %}
        </div>
    </div>

    <script>
        // Prevent page from being stored in cache
        window.addEventListener('pageshow', function(event) {
            if (event.persisted) {
                window.location.reload();
            }
        });

        // Wait for all elements to load before initializing
        document.addEventListener('DOMContentLoaded', function() {
            const serversList = document.getElementById('servers-list');
            const channelsList = document.getElementById('channels-list');
            const messageInput = document.getElementById('message-input');
            const sendBtn = document.getElementById('send-btn');
            const charCount = document.getElementById('char-count');
            const selectedChannelsTags = document.getElementById('selected-channels-tags');
            const channelSearch = document.getElementById('channel-search');
            const searchTagsContainer = document.getElementById('search-tags');
            const serverSearch = document.getElementById('server-search');
            const selectedSearch = document.getElementById('selected-search');

            let guilds = [];
            let serverChannels = {}; // Cache for channels by guild ID
            let selectedChannels = []; // Array for multiple channel selection
            let selectedGuild = null; // Currently selected guild
            let searchTags = []; // Search filter tags
            let serverSearchText = ''; // Server search filter
            let selectedSearchText = ''; // Selected channels search filter
            let currentServerColor = 'rgba(51, 95, 255, 0.6)'; // Current server's dominant color
            let isSending = false; // Track if messages are being sent
            let failedChannels = new Map(); // Track channels that failed to send with failure type
            let isConfirmState = false; // Track if send button is in confirmation state
            let confirmTimeout = null; // Timeout for auto-reset confirmation

            // Check session on API error
            function handleSessionError(response) {
                if (response.status === 401) {
                    // Auto logout on session expiry
                    window.location.href = '/logout';
                }
            }

            // Warn user before leaving if messages are being sent
            window.addEventListener('beforeunload', (e) => {
                if (isSending) {
                    e.preventDefault();
                    e.returnValue = '';
                    return '';
                }
            });

            // Dropdown menu toggle
            const menuIcon = document.getElementById('menu-icon');
            const dropdownMenu = document.getElementById('dropdown-menu');

            if (menuIcon) {
                menuIcon.addEventListener('click', (e) => {
                    e.stopPropagation();
                    dropdownMenu.classList.toggle('show');
                });
            }

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (dropdownMenu && !dropdownMenu.contains(e.target) && menuIcon && !menuIcon.contains(e.target)) {
                    dropdownMenu.classList.remove('show');
                }
            });

            // Load saved data from localStorage (persists across sessions)
            function loadSelectedChannels() {
                const saved = localStorage.getItem('selectedChannels');
                if (saved) {
                    try {
                        selectedChannels = JSON.parse(saved);
                    } catch (e) {
                        console.error('Error loading saved channels:', e);
                        selectedChannels = [];
                    }
                }
            }

            function loadMessageText() {
                const saved = localStorage.getItem('messageText');
                if (saved && messageInput) {
                    messageInput.value = saved;
                    if (charCount) {
                        charCount.textContent = saved.length;
                    }
                }
            }

            // Save data to localStorage (persists across sessions)
            function saveSelectedChannels() {
                localStorage.setItem('selectedChannels', JSON.stringify(selectedChannels));
            }

            function saveMessageText() {
                if (messageInput) {
                    localStorage.setItem('messageText', messageInput.value);
                }
            }
            
            // Add search tag
            function addSearchTag(text) {
                if (searchTags.length >= 6) {
                    alert('Maximum 6 tags allowed');
                    return;
                }
                if (!searchTags.includes(text.toLowerCase()) && text.trim()) {
                    searchTags.push(text.toLowerCase());
                    updateSearchTagsDisplay();
                    channelSearch.value = '';
                    if (selectedGuild) {
                        renderChannels();
                    }
                }
            }

            // Remove search tag
            function removeSearchTag(tag) {
                searchTags = searchTags.filter(t => t !== tag);
                updateSearchTagsDisplay();
                if (selectedGuild) {
                    renderChannels();
                }
            }
            
            // Update search tags display
            function updateSearchTagsDisplay() {
                searchTagsContainer.innerHTML = '';
                searchTags.forEach(tag => {
                    const tagEl = document.createElement('div');
                    tagEl.className = 'search-tag';
                    tagEl.innerHTML = `
                        ${tag}
                        <span class="search-tag-remove" data-tag="${tag}">‚úï</span>
                    `;
                    tagEl.querySelector('.search-tag-remove').addEventListener('click', () => {
                        removeSearchTag(tag);
                    });
                    searchTagsContainer.appendChild(tagEl);
                });
            }
            
            // Handle channel search input
            if (channelSearch) {
                channelSearch.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && channelSearch.value.trim()) {
                        addSearchTag(channelSearch.value);
                    }
                });
            }

            // Handle server search input
            if (serverSearch) {
                serverSearch.addEventListener('input', (e) => {
                    serverSearchText = e.target.value.toLowerCase();
                    renderServers();
                });
            }

            // Handle selected channels search input
            if (selectedSearch) {
                selectedSearch.addEventListener('input', (e) => {
                    selectedSearchText = e.target.value.toLowerCase();
                    updateSelectedDisplay();
                });
            }
            
            // Render servers list with search filter
            function renderServers() {
                if (!serversList) return;

                serversList.innerHTML = '';

                if (!guilds || guilds.length === 0) {
                    serversList.innerHTML = '<div style="color: #949ba4; padding: 1rem;">No servers found</div>';
                    return;
                }

                // Filter guilds by search text
                const filteredGuilds = guilds.filter(guild =>
                    guild.name.toLowerCase().includes(serverSearchText)
                );

                if (filteredGuilds.length === 0) {
                    serversList.innerHTML = '<div style="color: #949ba4; padding: 1rem;">No servers match search</div>';
                    return;
                }

                filteredGuilds.forEach(guild => {
                    const serverItem = document.createElement('div');
                    serverItem.className = 'server-item';
                    serverItem.dataset.guildId = guild.id;

                    const iconHtml = guild.icon
                        ? `<img src="https://cdn.discordapp.com/icons/${guild.id}/${guild.icon}.png" alt="${guild.name}" class="server-icon">`
                        : `<div class="server-icon-placeholder">${guild.name.charAt(0).toUpperCase()}</div>`;

                    serverItem.innerHTML = `
                        ${iconHtml}
                        <div class="server-info">
                            <div class="server-name">${guild.name}</div>
                            <div class="server-count" style="display: none;">0 selected</div>
                        </div>
                    `;

                    serverItem.addEventListener('click', () => selectServer(guild));
                    serversList.appendChild(serverItem);

                    // Update server count based on saved selections
                    updateServerCount(guild.id);

                    // Restore active state if this is the selected guild
                    if (selectedGuild && selectedGuild.id === guild.id) {
                        serverItem.classList.add('active');
                    }
                });
            }

            // Fetch all guilds and build UI
            async function initializeUI() {
                loadSelectedChannels();
                loadMessageText();
                guilds = {{ guilds|tojson }};

                // Render servers
                renderServers();

                // Update selected display
                updateSelectedDisplay();
                updateSendButton();
            }

            // Extract dominant color from image
            function getDominantColor(imageUrl, callback) {
                const img = new Image();
                img.crossOrigin = 'Anonymous';
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    let r = 0, g = 0, b = 0, count = 0;

                    // Sample every 10th pixel for performance
                    for (let i = 0; i < data.length; i += 40) {
                        r += data[i];
                        g += data[i + 1];
                        b += data[i + 2];
                        count++;
                    }

                    r = Math.floor(r / count);
                    g = Math.floor(g / count);
                    b = Math.floor(b / count);

                    callback(`rgb(${r}, ${g}, ${b})`);
                };
                img.onerror = function() {
                    callback('rgba(51, 95, 255, 0.6)'); // Fallback to default blue
                };
                img.src = imageUrl;
            }

            // Select a server and load its channels
            async function selectServer(guild) {
                // Set selected guild immediately
                selectedGuild = guild;
                const guildId = guild.id;

                // Update active state
                document.querySelectorAll('.server-item').forEach(item => {
                    item.classList.remove('active');
                    item.style.borderColor = '';
                    item.style.boxShadow = '';
                });

                const activeItem = document.querySelector(`[data-guild-id="${guildId}"]`);
                if (activeItem) {
                    activeItem.classList.add('active');
                }

                // Apply dominant color from server icon
                if (guild.icon) {
                    const iconUrl = `https://cdn.discordapp.com/icons/${guildId}/${guild.icon}.png`;
                    getDominantColor(iconUrl, (color) => {
                        // Only update if this guild is still selected
                        if (selectedGuild && selectedGuild.id === guildId) {
                            currentServerColor = color;
                            if (activeItem) {
                                activeItem.style.borderColor = color;
                                activeItem.style.boxShadow = `0 0 15px ${color.replace('rgb', 'rgba').replace(')', ', 0.4)')}`;
                            }
                        }
                    });
                } else {
                    // Use default blue for servers without icons
                    currentServerColor = 'rgba(51, 95, 255, 0.6)';
                    if (activeItem) {
                        activeItem.style.borderColor = 'rgba(51, 95, 255, 0.6)';
                        activeItem.style.boxShadow = '0 0 15px rgba(51, 95, 255, 0.4)';
                    }
                }

                // Load channels if not cached
                if (!serverChannels[guildId]) {
                    channelsList.innerHTML = '<div class="loading-container"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="spinner"><circle cx="12" cy="12" r="10" stroke-opacity="0.25"></circle><path d="M12 2 A10 10 0 0 1 22 12" stroke-linecap="round"></path></svg> Loading channels...</div>';

                    try {
                        const response = await fetch(`/api/guild/${guildId}/channels`);

                        // Check if this guild is still selected
                        if (!selectedGuild || selectedGuild.id !== guildId) {
                            return;
                        }

                        if (!response.ok) {
                            handleSessionError(response);
                            return;
                        }

                        const data = await response.json();

                        if (data.channels) {
                            serverChannels[guildId] = data.channels.filter(ch => ch.type === 0);
                        } else {
                            serverChannels[guildId] = [];
                        }
                    } catch (error) {
                        console.error(`Error fetching channels:`, error);
                        serverChannels[guildId] = [];
                    }
                }

                // Only render if this guild is still selected
                if (selectedGuild && selectedGuild.id === guildId) {
                    renderChannels();
                }
            }
            
            // Render channels for selected server
            function renderChannels() {
                if (!selectedGuild) {
                    channelsList.innerHTML = '<div class="no-selection">Select a server to view channels</div>';
                    return;
                }

                channelsList.innerHTML = '';
                const channels = serverChannels[selectedGuild.id] || [];

                if (channels.length === 0) {
                    channelsList.innerHTML = '<div class="no-selection">No channels found</div>';
                    return;
                }

                // Filter channels by search tags (OR logic - any tag matches)
                let filteredChannels = channels;
                if (searchTags.length > 0) {
                    filteredChannels = channels.filter(channel =>
                        searchTags.some(tag => channel.name.toLowerCase().includes(tag))
                    );
                }

                if (filteredChannels.length === 0) {
                    channelsList.innerHTML = '<div class="no-selection">No channels match search</div>';
                    return;
                }

                filteredChannels.forEach(channel => {
                    const isSelected = selectedChannels.some(ch =>
                        ch.id === channel.id && ch.guildId === selectedGuild.id
                    );

                    const channelItem = document.createElement('div');
                    channelItem.className = `channel-item ${isSelected ? 'selected' : ''}`;
                    channelItem.dataset.channelId = channel.id;

                    // Create tick icon (only visible when selected)
                    const tickIcon = document.createElement('span');
                    tickIcon.className = 'channel-tick';
                    tickIcon.innerHTML = '‚úì';
                    tickIcon.style.display = isSelected ? 'inline-block' : 'none';

                    const label = document.createElement('label');
                    label.className = 'channel-label';
                    label.innerHTML = `#${channel.name}`;

                    channelItem.appendChild(tickIcon);
                    channelItem.appendChild(label);

                    // Apply server color to selected channel
                    if (isSelected) {
                        channelItem.style.borderColor = currentServerColor;
                        channelItem.style.boxShadow = `0 0 15px ${currentServerColor.replace('rgb', 'rgba').replace(')', ', 0.4)')}`;
                    }

                    // Click anywhere on channel item to toggle selection
                    channelItem.addEventListener('click', () => {
                        // Check current selection state at click time, not render time
                        const currentlySelected = selectedChannels.some(ch =>
                            ch.id === channel.id && ch.guildId === selectedGuild.id
                        );
                        toggleChannel(channel, !currentlySelected);
                    });

                    channelsList.appendChild(channelItem);
                });
            }
            
            // Toggle channel selection
            function toggleChannel(channel, isChecked) {
                if (!selectedGuild) return;

                const isCurrentlySelected = selectedChannels.some(ch =>
                    ch.id === channel.id && ch.guildId === selectedGuild.id
                );

                if (isChecked && !isCurrentlySelected) {
                    selectedChannels.push({
                        id: channel.id,
                        name: channel.name,
                        guildId: selectedGuild.id,
                        guildName: selectedGuild.name,
                        guildIcon: selectedGuild.icon || null
                    });
                    // Clear any failed status when re-selecting
                    const channelKey = `${selectedGuild.id}-${channel.id}`;
                    failedChannels.delete(channelKey);
                } else if (!isChecked && isCurrentlySelected) {
                    selectedChannels = selectedChannels.filter(ch =>
                        !(ch.id === channel.id && ch.guildId === selectedGuild.id)
                    );
                }

                // Save to localStorage
                saveSelectedChannels();

                // Update UI
                renderChannels();
                updateServerCount(selectedGuild.id);
                updateSelectedDisplay();
                updateSendButton();
            }
            
            // Update count badge on server
            function updateServerCount(guildId) {
                const count = selectedChannels.filter(ch => ch.guildId === guildId).length;
                const serverItem = document.querySelector(`[data-guild-id="${guildId}"]`);
                if (serverItem) {
                    const countEl = serverItem.querySelector('.server-count');
                    if (countEl) {
                        if (count > 0) {
                            countEl.textContent = `${count} selected`;
                            countEl.style.display = 'block';
                            serverItem.classList.add('has-selection');
                        } else {
                            countEl.style.display = 'none';
                            serverItem.classList.remove('has-selection');
                        }
                    }
                }
            }
            
            // Update selected channels display
            function updateSelectedDisplay() {
                if (selectedChannels.length > 0) {
                    // Filter channels by search text
                    let filteredChannels = selectedChannels;
                    if (selectedSearchText) {
                        filteredChannels = selectedChannels.filter(channel =>
                            channel.name.toLowerCase().includes(selectedSearchText) ||
                            channel.guildName.toLowerCase().includes(selectedSearchText)
                        );
                    }

                    if (filteredChannels.length === 0) {
                        selectedChannelsTags.innerHTML = '<div class="no-selection">No channels match search</div>';
                    } else {
                        let tagsHtml = '';
                        filteredChannels.forEach(channel => {
                            const iconHtml = channel.guildIcon
                                ? `<img src="https://cdn.discordapp.com/icons/${channel.guildId}/${channel.guildIcon}.png" alt="${channel.guildName}">`
                                : `<span>${channel.guildName.charAt(0).toUpperCase()}</span>`;

                            const channelKey = `${channel.guildId}-${channel.id}`;
                            const failureInfo = failedChannels.get(channelKey);

                            let failedClass = '';
                            let labelHtml = '';

                            if (failureInfo) {
                                if (failureInfo.type === 'ratelimit') {
                                    failedClass = ' rate-limited';
                                    labelHtml = '<span class="failure-label ratelimit">Rate Limited</span>';
                                } else {
                                    failedClass = ' failed-channel';
                                    labelHtml = '<span class="failure-label permission">Missing Permission</span>';
                                }
                            }

                            tagsHtml += `
                                <div class="selected-tag${failedClass}" data-channel-key="${channelKey}">
                                    <div class="tag-icon">${iconHtml}</div>
                                    <div class="tag-text">#${channel.name}</div>
                                    ${labelHtml}
                                    <button class="tag-remove" data-channel-id="${channel.id}" data-guild-id="${channel.guildId}">‚úï</button>
                                </div>
                            `;
                        });
                        selectedChannelsTags.innerHTML = tagsHtml;

                        // Add event listeners for remove buttons
                        selectedChannelsTags.querySelectorAll('.tag-remove').forEach(btn => {
                            btn.addEventListener('click', () => {
                                const channelId = btn.dataset.channelId;
                                const guildId = btn.dataset.guildId;
                                selectedChannels = selectedChannels.filter(ch =>
                                    !(ch.id === channelId && ch.guildId === guildId)
                                );
                                saveSelectedChannels();
                                updateSelectedDisplay();
                                if (selectedGuild && selectedGuild.id === guildId) {
                                    renderChannels();
                                }
                                updateServerCount(guildId);
                                updateSendButton();
                            });
                        });
                    }

                    // Show external clear all button
                    const clearAllBtn = document.getElementById('clear-all-btn');
                    clearAllBtn.style.display = 'block';
                    clearAllBtn.onclick = () => {
                        selectedChannels = [];
                        saveSelectedChannels();
                        updateSelectedDisplay();
                        if (selectedGuild) {
                            renderChannels();
                        }
                        guilds.forEach(g => updateServerCount(g.id));
                        updateSendButton();
                    };
                } else {
                    selectedChannelsTags.innerHTML = '<div class="no-selection">No channels selected</div>';
                    const clearAllBtn = document.getElementById('clear-all-btn');
                    clearAllBtn.style.display = 'none';
                }
            }
            
            // Update send button state
            function updateSendButton() {
                if (sendBtn && messageInput) {
                    sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim();
                    // Reset confirmation state when channels or message changes
                    resetConfirmState();
                }
            }

            // Reset confirmation state
            function resetConfirmState() {
                if (isConfirmState) {
                    isConfirmState = false;
                    if (confirmTimeout) {
                        clearTimeout(confirmTimeout);
                        confirmTimeout = null;
                    }
                    // Restore original send button text
                    if (sendBtn) {
                        sendBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"></path></svg> Send';
                    }
                }
            }
            
            // Message input listener
            if (messageInput) {
                messageInput.addEventListener('input', function() {
                    if (charCount) {
                        charCount.textContent = this.value.length;
                    }
                    saveMessageText();
                    updateSendButton();
                });
            }
            
            // Send button handler
            if (sendBtn) {
                sendBtn.addEventListener('click', async function() {
                    if (selectedChannels.length > 0 && messageInput && messageInput.value.trim()) {
                        // First click: change to confirmation state
                        if (!isConfirmState) {
                            isConfirmState = true;
                            const channelCount = selectedChannels.length;
                            sendBtn.innerHTML = `Confirm sending ${channelCount} message${channelCount !== 1 ? 's' : ''}?`;

                            // Auto-reset after 3 seconds
                            confirmTimeout = setTimeout(() => {
                                resetConfirmState();
                            }, 3000);

                            return; // Don't send yet, wait for second click
                        }

                        // Second click: proceed with sending
                        // Clear the confirmation timeout since user confirmed
                        if (confirmTimeout) {
                            clearTimeout(confirmTimeout);
                            confirmTimeout = null;
                        }
                        isConfirmState = false;

                        // Clear previous failed channels
                        failedChannels.clear();

                        isSending = true;
                        sendBtn.disabled = true;
                        sendBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="spinner"><circle cx="12" cy="12" r="10" stroke-opacity="0.25"></circle><path d="M12 2 A10 10 0 0 1 22 12" stroke-linecap="round"></path></svg> Sending...';

                        // Send messages one by one for real-time usage tracking
                        let successCount = 0;
                        let failedList = [];

                        // Helper function to wait/delay
                        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

                        // Get custom delay setting from localStorage (default to 1000ms)
                        const customDelay = parseInt(localStorage.getItem('messageDelay') || '1000');

                        try {
                            for (let i = 0; i < selectedChannels.length; i++) {
                                const channel = selectedChannels[i];

                                // Update progress in button
                                sendBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="spinner"><circle cx="12" cy="12" r="10" stroke-opacity="0.25"></circle><path d="M12 2 A10 10 0 0 1 22 12" stroke-linecap="round"></path></svg> Sending ${i + 1}/${selectedChannels.length}...`;

                                // Send message (no retry for rate limits)
                                const response = await fetch('/api/send-message-single', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                    },
                                    body: JSON.stringify({
                                        channel: channel,
                                        message: messageInput.value
                                    })
                                });

                                const result = await response.json();

                                if (result.success) {
                                    successCount++;
                                } else if (response.status === 429) {
                                    // Rate limited - mark and skip (don't retry)
                                    const channelKey = `${channel.guildId}-${channel.id}`;
                                    failedChannels.set(channelKey, { type: 'ratelimit' });
                                    failedList.push(`${channel.name} (Rate limited)`);
                                } else {
                                    // Other error
                                    const channelKey = `${channel.guildId}-${channel.id}`;
                                    failedChannels.set(channelKey, { type: 'permission' });
                                    failedList.push(`${channel.name} (${result.error})`);
                                }

                                // Update display after each message
                                updateSelectedDisplay();

                                // Add delay between messages based on user setting
                                // Only delay if there are more messages to send
                                if (i < selectedChannels.length - 1 && customDelay > 0) {
                                    await delay(customDelay);
                                }
                            }

                            // Show final summary
                            let successMsg = `‚úÖ Message sent to ${successCount} channel(s)`;

                            if (failedList.length > 0) {
                                successMsg += `\n\n‚ö†Ô∏è Failed (${failedList.length}):\n${failedList.map(f => `‚Ä¢ ${f}`).join('\n')}`;
                            }

                            alert(successMsg);
                        } catch (error) {
                            console.error('Send error:', error);
                            alert(`‚ùå Error sending message: ${error.message}`);
                        } finally {
                            isSending = false;
                            sendBtn.disabled = selectedChannels.length === 0 || !messageInput.value.trim();
                            sendBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"></path></svg> Send';
                        }
                    }
                });
            }

            // Initialize on load
            initializeUI();
        });
    </script>
</body>
</html>
